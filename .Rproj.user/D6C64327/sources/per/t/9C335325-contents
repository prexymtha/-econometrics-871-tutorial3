---
title: "Timeseries_Tutorial_2"
author: "Precious Nhamo"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Restrictions, cross equation restrictions, and structural identification


# This is for clearing your R memory to make sure than non of your "unattended" work interferes with your current code 

```{r}
# Clear the console and the environment
rm(list = ls())  # Remove all objects from the environment
graphics.off()  # Turn off all graphics devices
cat('\f')  # Clear the console ( in the original code not in markdown because it doesn't clear when knitting )

```

# Data
#Load the dataset again 
```{r}
fulton <- read.delim2("data/fulton.txt")
```

# A simple lag function.
# Here please write down the equations you need for VARs and see what variables you need and how you can create them 
# Logic: a lag shifts the series down by k positions and pads the top with NA.

```{r}
lagpad <- function(x, k) {
  if (!is.vector(x)) stop("x must be a vector")
  if (!is.numeric(x)) stop("x must be numeric")
  if (!is.numeric(k) || length(k) != 1) stop("k must be a single number")
  c(rep(NA, k), x)[1:length(x)]
}

```

# Create lags used in the VAR style system

```{r}
fulton$LogPriceL1    <- lagpad(fulton$LogPrice, 1)
fulton$LogQuantityL1 <- lagpad(fulton$LogQuantity, 1)
```

# Holiday dummy as in tutorial notes [ or from tutorial 1 , alternatively you could save the data you cleaned in tutorial 1 and not repeat this step ]

```{r}
fulton$Holiday <- 0
fulton$Holiday[c(18, 34, 95)] <- 1

```

# Packages
library(pacman)
p_load(lmtest, systemfit, bbmle, mvtnorm, sem, tidyverse, huxtable, broom)

############################################################
# Part 1: System estimation and linear restrictions
############################################################

# Reduced form system (VAR style) in systemfit
# Equation form:
#   LogPrice_t    = c1 + a11 LogPrice_{t-1} + a12 LogQuantity_{t-1} + controls + u1_t
#   LogQuantity_t = c2 + a21 LogPrice_{t-1} + a22 LogQuantity_{t-1} + controls + u2_t
#
# Logic: systemfit estimates the equations jointly, allowing correlated errors.
# This is useful because the shocks u1_t and u2_t can be correlated in markets.
```{r}
pEqn1 <- formula(LogPrice ~ 1 + LogPriceL1 + LogQuantityL1 + Stormy + Mixed + Holiday)
qEqn1 <- formula(LogQuantity ~ 1 + LogPriceL1 + LogQuantityL1 + Stormy + Mixed + Holiday)

sysEqn1 <- list(pEqn1, qEqn1)
var1 <- systemfit(sysEqn1, data = fulton)   # default method is OLS for each equation
```


# Teaching note:
# "1 +" is redundant because R includes an intercept by default.
# You would write "0 +" to remove the intercept.

# Exclusion restrictions by omission
# Logic: if theory says LogQuantityL1 should not appear, drop it from BOTH equations.

```{r}
pEqn2 <- formula(LogPrice ~ 1 + LogPriceL1 + Stormy + Mixed + Holiday)
qEqn2 <- formula(LogQuantity ~ 1 + LogPriceL1 + Stormy + Mixed + Holiday)
sysEqn2 <- list(pEqn2, qEqn2)
var2 <- systemfit(sysEqn2, data = fulton)

```

# Testing restrictions
# LR test logic:
#   LR = 2 (logLik(unrestricted) - logLik(restricted)) ~ Chi square(df = number of restrictions)
# If p value is large, restrictions are not rejected.


```{r}
lrtest(var2, var1)   # restricted first, unrestricted second is good practice

```

# Alternative: test restrictions without estimating restricted model
# This uses the unrestricted estimates and tests linear constraints on coefficients.
# Here, we test a12 = 0 and a22 = 0 (both LogQuantityL1 coefficients set to zero).
linearHypothesis(var1,
                 c("eq1_LogQuantityL1 = 0", "eq2_LogQuantityL1 = 0"),
                 test = "Chisq")

############################################################
# Part 1b: Manual restriction matrix option
############################################################

# systemfit can impose linear restrictions as R * beta = r.
# beta is the stacked coefficient vector across equations.
# R is a matrix with rows equal to number of restrictions.
# r is the right hand side vector, often zeros for exclusion restrictions.

resMat <- matrix(0, 2, var1$rank)
# You need to locate the correct coefficient positions.
# The tutorial uses:
resMat[1, 3] <- 1
resMat[2, 9] <- 1
resEql <- c(0, 0)

var3 <- systemfit(sysEqn1, data = fulton,
                  restrict.matrix = resMat,
                  restrict.rhs = resEql)

lrtest(var3, var1)

############################################################
# Part 1c: Why cross equation restrictions break weak exogeneity
############################################################

# Key logic:
# If parameters are shared across equations, you can no longer estimate each equation
# separately by OLS, because the parameter in one equation depends on the other equation.
# Then you need a joint estimator, such as maximum likelihood.

############################################################
# Part 1d: Cross equation restrictions using MLE (bbmle + mvtnorm)
############################################################

# Remove first observation because lagged variables create NA in row 1.
# Teaching note: attaching is convenient but can cause confusion in class.
# If you attach, remind them to detach later.
attach(fulton[2:nrow(fulton), ])

# Single equation MLE example (replicates OLS under normality)
# Model equation:
#   LogPrice_t = b10 + b11 LogPriceL1_t + b12 LogQuantityL1_t + b13 Stormy_t + b14 Mixed_t + b15 Holiday_t + e1_t
# Normality assumption:
#   e1_t ~ N(0, Sigma1)
#
# Log likelihood contribution is dnorm(residual, mean=0, sd=Sigma1)
# We minimise minus log likelihood.

LL_price <- function(b10 = 0, b11 = 0, b12 = 0, b13 = 0, b14 = 0, b15 = 0, Sigma1 = 0.5) {
  R1 <- LogPrice - b10 - LogPriceL1 * b11 - LogQuantityL1 * b12 - Stormy * b13 - Mixed * b14 - Holiday * b15
  dens <- suppressWarnings(dnorm(R1, mean = 0, sd = Sigma1))
  -sum(log(dens))
}

z1 <- mle2(LL_price)
summary(z1)

# Two equation joint MLE
# Assumption: (e1_t, e2_t) is jointly normal:
#   e_t ~ N(0, Sigma) where Sigma is 2x2 with variances and covariance
#
# dmvnorm evaluates the multivariate normal density for each row of residuals.

LL_2eq_ur <- function(
  b10 = 0, b11 = 0, b12 = 0, b13 = 0, b14 = 0, b15 = 0,
  b20 = 0, b21 = 0, b22 = 0, b23 = 0, b24 = 0, b25 = 0,
  Sigma1 = 1, Sigma2 = 1, cov = 0
) {
  R1 <- LogPrice    - b10 - LogPriceL1 * b11 - LogQuantityL1 * b12 - Stormy * b13 - Mixed * b14 - Holiday * b15
  R2 <- LogQuantity - b20 - LogPriceL1 * b21 - LogQuantityL1 * b22 - Stormy * b23 - Mixed * b24 - Holiday * b25
  Sigma <- matrix(c(Sigma1, cov,
                    cov,   Sigma2), 2, 2)
  dens <- suppressWarnings(dmvnorm(cbind(R1, R2), mean = c(0, 0), sigma = Sigma))
  -sum(log(dens))
}

# Example exclusion restrictions by fixing coefficients at zero
# fixed means these parameters are not estimated, they are set exactly.
z2 <- mle2(LL_2eq_ur, fixed = list(b12 = 0, b22 = 0), control = list(maxit = 1000))
z2

# Cross equation restriction example
# Logic: force Stormy and Mixed effects in equation 2 to be proportional to equation 1
# by using the SAME coefficients b13 and b14, scaled by ba in equation 2.
LL_2eq_cross <- function(
  b10 = 0, b11 = 0, b12 = 0, b13 = 0, b14 = 0, b15 = 0,
  b20 = 0, b21 = 0, b22 = 0, b25 = 0,
  Sigma1 = 1, Sigma2 = 1, cov = 0, ba = 1
) {
  R1 <- LogPrice    - b10 - LogPriceL1 * b11 - LogQuantityL1 * b12 - Stormy * b13 - Mixed * b14 - Holiday * b15
  R2 <- LogQuantity - b20 - LogPriceL1 * b21 - LogQuantityL1 * b22 - (Stormy * b13 + Mixed * b14) * ba - Holiday * b25
  Sigma <- matrix(c(Sigma1, cov,
                    cov,   Sigma2), 2, 2)
  dens <- suppressWarnings(dmvnorm(cbind(R1, R2), mean = c(0, 0), sigma = Sigma))
  -sum(log(dens))
}

z3 <- mle2(LL_2eq_cross, fixed = list(b12 = 0, b22 = 0))
z3

# Compare restricted vs unrestricted using LR test
anova(z2, z3)

# Interpreting Sigma parameters
# Sigma1 and Sigma2 are variances in the tutorial coding.
# Standard deviations are sqrt(variance).
sqrt(z3@fullcoef[["Sigma1"]])
sqrt(z3@fullcoef[["Sigma2"]])
z3@fullcoef[["cov"]] / (sqrt(z3@fullcoef[["Sigma1"]]) * sqrt(z3@fullcoef[["Sigma2"]]))

detach()

############################################################
# Part 2: Identification of structural models
############################################################

# Core idea from the lecture:
# Reduced form is about observables (price and quantity dynamics)
# Structural form is about economic objects like demand elasticity
#
# Identification problem:
# Can we uniquely recover structural parameters from reduced form parameters

# Step 1: Estimate congruent reduced form system (Table 15.1 style)
pEqn_rf <- formula(LogPrice ~ LogPriceL1 + Stormy + Mixed + Holiday)
qEqn_rf <- formula(LogQuantity ~ LogPriceL1 + Stormy + Mixed + Holiday)
sys_rf <- list(pEqn_rf, qEqn_rf)
rf <- systemfit(sys_rf, method = "OLS", data = fulton, maxit = 100)
summary(rf)

# Exact identification of demand using one instrument
# Logic:
# If Stormy affects supply (price equation) but does not enter demand directly,
# then Stormy can be an instrument for LogPrice in the demand equation.

# Structural demand equation (conditional):
#   LogQuantity_t = a0 + a1 LogPrice_t + a2 LogPriceL1_t + a3 Mixed_t + a4 Holiday_t + u_t
# Endogeneity problem:
#   LogPrice_t is correlated with u_t due to simultaneity (market clearing).
# Solution:
#   Use Stormy as an instrument for LogPrice.

pEqn_supply <- formula(LogPrice ~ LogPriceL1 + Stormy + Mixed + Holiday)
qEqn_demand <- formula(LogQuantity ~ LogPrice + LogPriceL1 + Mixed + Holiday)

sys_struct <- list(pEqn_supply, qEqn_demand)

# 2SLS in systemfit
# Instruments list includes exogenous regressors and the excluded instrument Stormy.
struct_2sls <- systemfit(sys_struct, method = "2SLS",
                         data = fulton,
                         inst = ~ Stormy + Mixed + Holiday + LogPriceL1)
summary(struct_2sls)

# Single equation 2SLS gives identical result under exact identification
m_exact <- tsls(LogQuantity ~ LogPrice + LogPriceL1 + Mixed + Holiday,
                data = fulton,
                instruments = ~ LogPriceL1 + Stormy + Mixed + Holiday)
summary(m_exact)

############################################################
# Over identification using SEM (full information ML)
############################################################

# Over identified means more instruments than endogenous variables in the equation.
# Then you need an additional restriction to ensure uniqueness.
# sem estimates the system via ML and provides an over identification test
# using the model chi square statistic.

# Path diagram style specification for an over identified demand equation:
# Here, omit Mixed from demand (an over identifying restriction).
fimlRaM3 <- matrix(c(
  "LogPrice <- LogPriceL1", "b11", NA,
  "LogPrice <- Stormy",     "b12", NA,
  "LogPrice <- Mixed",      "b13", NA,
  "LogPrice <- Holiday",    "b14", NA,
  "LogQuantity <- LogPrice",    "b21", NA,
  "LogQuantity <- LogPriceL1",  "b22", NA,
  "LogQuantity <- Holiday",     "b25", NA,
  "LogPrice <-> LogQuantity",   "cov1", NA,
  "LogPrice <-> LogPrice",      "sig1", 1,
  "LogQuantity <-> LogQuantity","sig2", 1
), ncol = 3, byrow = TRUE)

class(fimlRaM3) <- "mod"

exogVar <- c("LogPriceL1", "Stormy", "Mixed", "Holiday")
endogVar <- c("LogPrice", "LogQuantity")
allVar  <- c(exogVar, endogVar)

fimlResult3 <- sem(model = fimlRaM3,
                   S = cov(fulton[-1, allVar]),
                   N = nrow(fulton) - 1,
                   fixed.x = exogVar)

summary(fimlResult3)

# Teaching interpretation:
# Model chi square tests the over identifying restriction.
# Null: restrictions are valid, model behaves like exactly identified.
# If p value is large, you do not reject the restriction.

############################################################
# 2SLS for over identified demand equation
############################################################

# In over identified settings, 2SLS and FIML need not match exactly.
m_over <- tsls(LogQuantity ~ LogPrice + LogPriceL1 + Holiday,
               data = fulton,
               instruments = ~ LogPriceL1 + Stormy + Mixed + Holiday)
summary(m_over)
